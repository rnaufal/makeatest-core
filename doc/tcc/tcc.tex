\documentclass[12pt,a4paper,oneside]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage[alf]{abntcite}
\usepackage{url}

\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\usepackage[pdftex,table]{xcolor}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\renewcommand\rmdefault{ptm}

\begin{document}

\input{./cover.tex}
\input{./facepage.tex}

\chapter{Introdução}

\chapter{Conceitos Teóricos}

\chapter{Problemas}


\chapter{Padrão - Verificação de comportamento por anotações}

Padrão para solução do problema(mostrar que o isolamento da inicialização /verificação do teste, que são coisas de efeito externo e não pertencem a classe são feitas  usando anotação. )


\section{Contexto}
Na criação dos testes de um sistema, inicializar um cenário com dependências externas e verificar os efeitos externos de um teste é muito trabalho. São exemplos de efeitos externos verificar estado do banco de dados, iniciar um servidor de aplicação, validar existência de recursos como arquivos, entre outros. É desejável que seja possível que o desenvolvedor crie seu teste de forma mais amigável, podendo tanto configurar seu cenário como realizar as verificações dos efeitos, de forma a tornar mais legível e amigável a criação do teste.

\section{Problema}
Como configurar e verificar comportamentos por metadados em testes de unidade?

\section{Forças}
- Testes que necessitam de cenários para sua execução podem ser mais difíceis de se criar.\\
- Testes que precisam verificar muitos efeitos externos também podem ser mais difíceis de ser criar. \\
- Desenvolvedor deseja configurar cenários de testes de forma mais prática, podendo utilizar de metadados para configurar cenários, como por exemplo inicializar servidor, carregar valores em variáveis, etc.\\
- Utilizar anotações para verificar comportamento de testes.\\

\section{Aplicabilidade}
- Comportamentos que se repetem em vários projetos podem ser externalizados em anotações e seu uso no método de teste parametrizado em cada projeto. Exemplo, validação de conteúdo de uma tabela em banco de dados, verificação de conteúdo de arquivo texto, entre outros.\\

\section{Solução}
Durante a criação do teste, o desenvolvedor pode se deparar com inicializações de cenário de teste específicos de um teste ou genéricos da classe de teste como um todo. De acordo com o escopo da inicialização, ele pode utilizar anotação para anotar ou a classe de teste ou o método em si com a anotação de inicialização de cenário. (OBS: Isso ainda não existe????)
Para verificar comportamentos decorrentes do teste, o método de teste é anotado. Quando a anotação é processada, é verificado se o efeito esperado foi atingido. Após essa verificação, pode-se considerar que o teste falhou ou que foi executado com sucesso. Mais de uma anotação pode existir em cada método, e todas são processadas para garantir que o comportamento desejado foi atingido.

\section{Consequências}
(+)Utilizar anotações torna a configuração mais próxima do código.\\
(+)Solução mais legível e mais fácil de configurar\\
(+)Permite reuso quando o comportamento verificado pela anotação for genérico e puder ser utilizado em mais de projeto (estado de servidor, estado de banco de dados, etc)\\
(-)Uso de anotação está ligado a necessidade de recompilar código se parâmetros mudam, ao contrário de quando se utiliza arquivo externo.\\
(-)Mais difícil de depurar quando ocorrerem problemas, uma vez que há comportamento encapsulado em anotações. (????? será????)\\


\section{Usos Conhecidos}
Alguns frameworks de teste no mercado usam essa abordagem de anotar métodos de teste para verificar efeitos externos. Entre eles temos o JUnit com a Expected Exceptions, o Spring Framework com Commons Annotations e no JQuati as anotação de @MustExecute e @MustNotExecute.

\subsection{JUnit - Expected Exceptions}
O Excepted Exceptions do JUnit tem como objetivo verifica se o código testado lançou ou não uma exceção esperada.
O exemplo abaixo indica que por estarmos tentando acessar uma posição fora dos limites do array, uma exceção do tipo ``IndexOutOfBoundsException'' deve ser lançada, e estamos esperando por ela.
\begin{verbatim}
@Test(expected= IndexOutOfBoundsException.class) public void empty() { 
    new ArrayList<Object>().get(0); 
}
\end{verbatim}

\subsection{Spring Framework - Common annotations}
O Spring Framework prove um conjunto de anotações que podem ser usadas nos testes. De forma semelhando ao Expected Exceptions do JUnit, tem uma anotação denominada @ExpectedException. 
Essa anotação indica que é esperado o método anotado com a mesma lance uma exceção durante sua excecução. Se for lançada a exceção do tipo esperado durante a excecução o teste passa, caso não lance o teste falha.
Exemplo de uso:
\begin{verbatim}
@ExpectedException(IndexOutOfBoundsException.class)
public void empty() {
   new ArrayList<Object>().get(0);
}
\end{verbatim}

\subsection{JQuati}




\chapter{Framework para facilitar aplicação do padrão}

\chapter{Estudos de caso}



\end{document}
